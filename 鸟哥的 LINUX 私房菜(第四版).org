#+TITLE: 鸟哥的 LINUX 私房菜(第四版)
#+OPTIONS:

#+BEGIN_CENTER
计算机概论
#+END_CENTER

  由过去的经验当中,鸟哥发现到因为兴趣或生活所逼而必须要接触 Linux 的朋友,很多可能并非信息相关科系出身, 因 此对于计算机软/硬件方面的概念不熟。
  然而操作系统这种咚咚跟硬件有相当程度的关连性, 所以,如果不了解一下计算 器概论,要很快的了解 Linux 的概念是有点难度的。
  因此,鸟哥就自作聪明的新增一个小章节来谈谈计概啰!
  因为鸟哥 也不是信息相关学门出身,所以,写的不好的地方请大家多多指教啊!^_^

** 计算机: 辅助人脑的好工具

   所谓的计算机就是一种计算器,而计算器其实是: *接受用户输入指令与数据,经由中央处理器的数 学与逻辑单元运算处理后, 以产生或储存成有用的信息* 。
   因此,只要有输入设备 (不管是键盘还 是触摸屏) 及输出设备 (例如计算机屏幕或直接由打印机打印出来),让你可以输入数据使该机器产生 信息的, 那就是一部计算器了。

*** 计算机硬件的五大单元

    - 输入单元
    - 输出单元
    - CPU 内部的控制单元
    - 算数逻辑单元
    - 主存储器

*** 一切设计的起点: CPU 的架构

    - 精简指令集 (RISC) 系统
      - 如甲骨文 (Oracle) 公司的 SPARC 系列
      - IBM 公司的 Power Architecture (包括 PowerPC) 系列
      - 安谋公司 (ARM Holdings) 的 ARM CPU 系列等
    - 复杂指令集 (CISC) 系统
      - AMD、Intel、VIA 等的 x86 架构的 CPU
      - 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位升级到 16、32 位,后来 AMD 依此架构修改新 一代的 CPU 为 64 位, 为了区别两者的差异,因此 64 位的个人计算机 CPU 又被统称为 x86_64 的架构喔!

    #+BEGIN_EXAMPLE
    例题:
    最新的 Intel/AMD 的 x86 架构中,请查询出多媒体、虚拟化、省电功能
各有哪些重要的微指令集?(仅供参考)
    答:
    多媒体微指令集:MMX, SSE, SSE2, SSE3, SSE4, AMD-3DNow!
    虚拟化微指令集:Intel-VT, AMD-SVM
    省电功能:Intel-SpeedStep, AMD-PowerNow!
     64/32 位兼容技术:AMD-AMD64, Intel-EM64T
    #+END_EXAMPLE

*** 其他单元的设备

    - 系统单元 ::
    系统单元包括 CPU 与内存及主板相关组件。
    而主板上头其实还有很多的连接 界面与相关的适配卡,包括鸟哥近期常使用的 PCI-E 10G 网络卡、 磁盘阵列卡、还有显示适配器等等。
    尤其是显示适配器,这东西对于玩 3D 游戏来说是非常重要的一环,他与显示的精致度、色彩与分辨率都有 关系。
    - 记忆单元 ::
    包括主存储器 (main memory, RAM) 与辅助内存,其中辅助内存其实就是大家常听到的『储存 装置』啰!
    包括硬盘、软盘、光盘、磁带等等的。
    - 输入、输出单元 ::
    同时涵盖输入输出的设备最常见的大概就是触摸屏了。
    至于单纯的输入设备包括前面提 到的键盘鼠标之外,目前的体感装置也是重要的输入设备喔!
    至于输出设备方面,除了屏幕外,打印机、音效喇叭、HDMI 电视、投影机、蓝芽耳机等等,都算喔!

*** 运作流程

    - CPU=脑袋瓜子 ::
    每个人会作的事情都不一样(微指令集的差异),但主要都是透过脑袋瓜子来进行判断与控制身体各部分的活动;
    - 主存储器=脑袋中放置正在被思考的数据的区块 ::
    在实际活动过程中,我们的脑袋瓜子需要有外界刺激的数 据 (例如光线、环境、语言等) 来分析,那这些互动数据暂时存放的地方就是主存储器,主要是用来提供给 脑袋瓜子判断用的信息。
    - 硬盘=脑袋中放置回忆的记忆区块 ::
    跟刚刚的主存储器不同,主存储器是提供脑袋目前要思考与处理的信息, 但是有些生活琐事或其他没有要立刻处理的事情, 就当成回忆先放置到脑袋的记忆深处吧!
    那就是硬盘!
    主要目的是将重要的数据记录起来,以便未来将这些重要的经验再次的使用;
    - 主板=神经系统 ::
    好像人类的神经一样,将所有重要的组件连接起来,包括手脚的活动都是脑袋瓜子发布命 令后, 透过神经(主板)传导给手脚来进行活动啊!
    - 各项接口设备=人体与外界沟通的手、脚、皮肤、眼睛等 ::
    就好像手脚一般,是人体与外界互动的重要关键!
    - 显示适配器=脑袋中的影像 ::
    将来自眼睛的刺激转成影像后在脑袋中呈现,所以显示适配器所产生的数据源也是 CPU 控制的。
    -电源供应器 (Power)=心脏 ::
    所有的组件要能运作得要有足够的电力供给才行!这电力供给就好像心脏一样,如果心脏不够力, 那么全身也就无法动弹的!
    心脏不稳定呢?那你的身体当然可能断断续续的~不稳定!

*** 计算机用途的分类

    - 超级计算机(Supercomputer) ::
    超级计算机是运作速度最快的计算机,但是他的维护、操作费用也最高!主要是用于需要有高速计算的计 划中。
    例如:国防军事、气象预测、太空科技,用在模拟的领域较多。
    详情也可以参考: 国家高速网络 与计算中心 http://www.nchc.org.tw 的介绍!
    至于全世界最快速的前 500 大超级计算机,则请参考: http://www.top500.org。
    - 大型计算机(Mainframe Computer) ::
    大型计算机通常也具有数个高速的 CPU,功能上虽不及超级计算机,但也可用来处理大量资料与复杂的运算。
    例如大型企业的主机、全国性的证券交易所等每天需要处理数百万笔数据的企业机构, 或者是大型 企业的数据库服务器等等。
    - 迷你计算机(Minicomputer) ::
    迷你计算机仍保有大型计算机同时支持多用户的特性,但是主机可以放在一般作业场所, 不必像前两个大 型计算机需要特殊的空调场所。
    通常用来作为科学研究、工程分析与工厂的流程管理等。
    - 工作站(Workstation) ::
    工作站的价格又比迷你计算机便宜许多,是针对特殊用途而设计的计算机。
    在个人计算机的效能还没有提升到目前的状况之前, 工作站计算机的性能/价格比是所有计算机当中较佳的, 因此在学术研究与工程分析方面相当常见。
    - 微电脑(Microcomputer) ::
    个人计算机就属于这部份的计算机分类,也是我们本章主要探讨的目标!
    体积最小,价格最低,但功能还 是五脏俱全的!
    大致又可分为桌上型、笔记型等等。

*** 计算机上面常用的计算单位 (容量、速度等)

    - 容量单位 ::
    计算机对数据的判断主要依据有没有通电来记录信息,所以理论上对于每一个纪录单位而言,它只认 识 0 与 1 而已。
    0/1 这个二进制的的单位我们称为 bit。
    但 bit 实在太小了,所以在储存数据时每份简单的数据都会使用到 8 个 bits 的大小来记录,因此定义出 byte 这个单位, 他们的关系为:
    \[1 Byte = 8 bits\]
    不过同样的,Byte 还是太小了,在较大的容量情况下, 使用 byte 相当不容易判断数据的大小, 举例来说, 1000000 bytes 这样的显示方式你能够看得出有几个零吗?
    所以后来就有一些常见的简化单 位表示法, 例如 K 代表 1024 byte, M 代表 1024K 等。
    而这些单位在不同的进位制下有不同的数 值表示,底下就列出常见的单位与进位制对应:

    | 进位制 | Kilo | Mega  | Giga  | Tera  | Peta  | Exa   | Zetta |
    |--------+------+-------+-------+-------+-------+-------+-------|
    | 二进制 | 1024 | 1024K | 1024M | 1024G | 1024T | 1024P | 1024E |
    | 十进制 | 1000 | 1000K | 1000M | 1000G | 1000T | 1000P | 1000E |

    - 速度单位 ::
    CPU 的指令周期常使用 MHz 或者是 GHz 之类的单位,这个 Hz 其实就是秒分之一。
    而在网络传 输方面,由于网络使用的是 bit 为单位, 因此网络常使用的单位为 Mbps 是 Mbits per second, 亦即是每秒多少 Mbit。
    举例来说,大家常听到的 20M/5M 光世代传输速度, 如果转成文件容量的 byte 时, 其实理论最大传输值为:每秒 2.5Mbyte/ 每秒 625Kbyte 的下载/上传速度喔!

    #+BEGIN_EXAMPLE
    例题:
    假设你今天购买了 500GB 的硬盘一颗, 但是格式化完毕后却只剩下
460GB 左右的容量, 这是什么原因?
    答:
    因为一般硬盘制造商会使用十进制的单位, 所以 500GByte 代表为
500*1000*1000*1000Byte 之意。
    转成文件的容 量单位时使用二进制(1024 为底), 所以就成为 466GB
左右的容量了。
    硬盘厂商并非要骗人, 只是因为硬盘的最小物理量为 512Bytes,
最小的组成单位为扇区(sector), 通常硬盘容量的计算采用『多少个
 sector, 所以才会使用十进制来处理的。
    相关的硬盘信息在这一章后面会提到的!
    #+END_EXAMPLE

** 个人计算机架构与相关设备组件

   一般消费者常说的计算机通常指的就是 x86 的个人计算机架构, 因此我们有必要来了解一下这个架构的各个组件。
   事实上, Linux 最早在发展的时候, 就是依据个人计算机的架构来发展的, 所以真的 得要了解一下呢!
   另外,早期两大主流 x86 开发商(Intel, AMD)的 CPU 架构与设计理念都有些许差异。
   不过互相学习对方长处的结果, 就是两者间的架构已经比较类似了。
   由于目前市场占有率还是以 Intel 为大宗,因此底下以目前(2015)相对较新的 Intel 主板架构来谈谈:

   #+BEGIN_QUOTE
   由于主板是链接各组件的一个重要项目,因此在主板上面沟通各部组件的芯片组设计优劣,就会影响 效能不少喔!
   早期的芯片组通常分为两个网桥来控制各组件的沟通, 分别是:
   - 北桥 ::
   负责链接速 度较快的 CPU、主存储器与显示适配器界面等组件;
   - 南桥 ::
   负责连接速度较慢的装置接口, 包括 硬盘、USB、网络卡等等。(芯片组的南北桥与三国的大小乔没有关系 @_@)。

   不过由于北桥最重要 的就是 CPU 与主存储器之间的桥接,因此目前的主流架构中, 大多将北桥内存控制器整合到 CPU 封装当中了。
   所以上图你只会看到 CPU 而没有看到以往的北桥芯片喔!
   #+END_QUOTE

   早期芯片组分南北桥,北桥可以连接 CPU、主存储器与显示适配器。
   只是 CPU 要读写到主存储器的动作,还需要北桥的支持,也就是 CPU 与主存储器的交流, 会瓜分掉北桥的总可用带宽,真浪 费!
   因此目前将记忆控制器整合到 CPU 后,CPU 与主存储器之间的沟通是直接交流,速度较快之外,也不会消耗 更多的带宽!

*** 执行脑袋运算与判断的 CPU

    x86 个人计算机的 CPU 主要供货商为 Intel 与 AMD,目前(2015)主流的 CPU 都是双核以上的架构了!
    原本的单核心 CPU 仅有一个运算单元,所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运 算核心, 简单的说,就是一个实体的 CPU 外壳中,含有两个以上的 CPU 单元就是了。

    不同的 CPU 型号大多具有不同的脚位(CPU 上面的插脚),能够搭配的主板芯片组也不同, 所以当你 想要将你的主机升级时,不能只考虑 CPU,你还得要留意你的主板上面所支援的 CPU 型号喔!
    不然买了最新的 CPU 也不能够安插在你的旧主板上头的!
    目前主流的 CPU 有 Intel 的 i3/i5/i7 系列产 品中,甚至先后期出厂的类似型号的脚位也不同, 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则 使用 FCLGA1150 脚位,挑选时必须要很小心喔!

    我们前面谈到 CPU 内部含有微指令集,不同的微指令集会导致 CPU 工作效率的优劣。
    除了这点之外, CPU 效能的比较还有什么呢?
    那就是 CPU 的频率了!
    什么是频率呢?
    简单的说, 频率就是 CPU 每 秒钟可以进行的工作次数。
    所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。
    举例来说, Intel 的 i7-4790 CPU 频率为 3.6GHz, 表示这颗 CPU 在一秒内可以进行 3.6x109 次工作,每次工作都可以进行少数的指令运作之意。

    #+BEGIN_QUOTE
    注意,不同的 CPU 之间不能单纯的以频率来判断运算效能喔!
    这是因为每颗 CPU 的 微指令集不相同,架构也不见得一样,可使用的第二层快取及其计算器制可能也不同, 加上每次频率能够进行的工作指令数也不同!
    所以,频率目前仅能用来比较同款 CPU 的速度!
    #+END_QUOTE

**** CPU的工作频率:外频与倍频

     早期的 CPU 架构主要透过北桥来链接系统最重要的 CPU、主存储器与显示适配器装置。
     因为所有 的设备都得掉透过北桥来连结,因此每个设备的工作频率应该要相同。
     于是就有所谓的前端总线 (FSB) 这个东西的产生。
     但因为 CPU 的指令周期比其他的设备都要来的快,又为了要满足 FSB 的 频率,因此厂商就在 CPU 内部再进行加速, 于是就有所谓的外频与倍频了。

     总结来说,在早期的 CPU 设计中, *所谓的外频指的是 CPU 与外部组件进行数据传输时的速度, 倍频则是 CPU 内部用来加速工作效能的一个倍数, 两者相乘才是 CPU 的频率速度* 。
     例如 Intel Core 2 E8400 的内频为 3.0GHz, 而外频是 333MHz, 因此倍频就是 9 倍啰!
     (3.0G=333Mx9, 其中 1G=1000M)

     但如此一来所有的数据都被北桥卡死了,北桥又不可能比 CPU 更快,因此这家伙常常是系统效能的瓶颈。
     为了解决这个问题,新的 CPU 设计中, 已经将内存控制器整合到 CPU 内部,而链接 CPU 与内存、显示适配器的控制器的设计,在 Intel 部份使用 QPI (Quick Path Interconnect) 与 DMI 技术, 而 AMD 部份则使用 Hyper Transport 了,这些技术都可以让 CPU 直接与主存储器、显示适配器等 设备分别进行沟通,而不需要透过外部的链接芯片了。
     因为现在没有所谓的北桥了 (整合到 CPU 内),因此,CPU 的频率设计就无须考虑得要同步的外频, 只需要考虑整体的频率即可。
     所以,如果你经常有查阅自己 CPU 频率的习惯, 当使用 cpu-z 这个软件时,应该会很惊讶的发现到,怎么外频变成 100MHz 而倍频可以到达 30 以上!
     相当有趣 呢!
     #+BEGIN_QUOTE
     现在 Intel 的 CPU 会主动帮妳超频喔!例如 i7-4790 这颗 CPU 的规格中,基本频率为 3.6GHz,但是最高可自动超频到 4GHz 喔!
     透过的是 Intel 的 turbo 技术。
     同时,如果你没有大量 的运算需求, 该 CPU 频率会降到 1.xGHz 而已, 藉此达到节能省电的目的!
     所以,各位好朋友,不需要自己手动超频了!
     Intel 已经自动帮妳进行超频了...所以,如果妳用 cpu-z 观察 CPU 频率,发现该频率会一直自动变动, 很正常!
     你的系统没坏掉!
     #+END_QUOTE

**** 32位与64位的CPU与总线『宽度』

     从前面的简易说明中,我们知道 CPU 的各项数据通通得要来自于主存储器。
     因此,如果主存储器能 提供给 CPU 的数据量越大的话,当然整体系统的效能应该也会比较快!
     那如何知道主存储器能提 供的数据量呢?
     此时还是得要藉由 CPU 内的内存控制芯片与主存储器间的传输速度 *前端总线速度 (Front Side Bus, FSB)* 来说明。

     与 CPU 的频率类似的,主存储器也是有其工作的频率,这个频率限制还是来自于 CPU 内的内存控 制器所决定的。
     CPU 内建的内存控制芯片对主存储器的工作频率最高可达到 1600MHz。
     这只是工作频率(每秒几次)。
     一般来说,每次频率能够传输的数据量,大多为 64 位, 这 个 64 位就是所谓的『宽度』了!
     因此CPU 可以从内存中取得的最快带 宽就是 1600MHz * 64bit = 1600MHz * 8 bytes = 12.8Gbyte/s。

     与总线宽度相似的, *CPU每次能够处理的数据量称为字组大小(word size)*, 字组大小依据 CPU 的设计而有 32 位与 64 位。 *我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的*!
     早期的 32 位 CPU 中, 因为 CPU 每次能够解析的数据量有限,因此由主存储器传来的数据量就有所限制了。
     这也导致 32 位的 CPU 最多只能支持最大到 4GBytes 的内存。

     #+BEGIN_QUOTE
     得利于北桥整合到 CPU 内部的设计,CPU 得以『个别』跟各个组件进行沟通!
     因此, 每种组件与 CPU 的沟通具有很多不同的方式!
     例如主存储器使用系统总线带宽来与 CPU 沟通。
     而显示适配器则 透过 PCI-E 的序列通道设计来与 CPU 沟通喔!
     详细说明我们在本章稍后的主板部份再来谈谈。
     #+END_QUOTE

**** CPU等级

     由于 x86 架构的 CPU 在 Intel 的 Pentium 系列(1993 年)后就有不统一的脚位与设计,为了将不同种类 的 CPU 规范等级,所以就有 i386,i586,i686 等名词出现了。
     基本上,在 Intel Pentium MMX 与 AMD K6 年代的 CPU 称为 i586 等级, 而 Intel Celeron 与 AMD Athlon(K7)年代之后的 32 位 CPU 就称为 i686 等级。
     至于目前的 64 位 CPU 则统称为 x86_64 等级。

     目前很多的程序都有对 CPU 做优化的设计, 万一哪天你发现一些程序是注明给 x86_64 的 CPU 使用 时, 就不要将他安装在 686 以下等级的计算机中,否则可是会无法执行该软件的!
     不过,在 x86_64 的硬件下倒是可以安装 386 的软件喔!
     也就是说,这些东西具有向下兼容的能力啦!

**** 超线程 (Hyper-Threading, HT)

     我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了,但是 Intel 还有个很怪的东西,叫 做 CPU 的超线程 (Hyper-Threading) 功能!
     那个是啥鬼东西?
     我们知道现在的 CPU 指令周期都太 快了,因此运算核心经常处于闲置状态下。
     而我们也知道现在的系统大多都是多任务的系统, 同时 间有很多的程序会让 CPU 来执行。
     因此,若 CPU 可以假象的同时执行两个程序,不就可以让系统效能增加了吗?
     反正 CPU 的运算能力还是没有用完啊!

     那是怎么达成的啊这个 HT 功能?
     强者鸟哥的同事蔡董大大用个简单的说明来解释。
     在每一个 CPU 内部将重要的缓存器 (register) 分成两群, 而让程序分别使用这两群缓存器。也就是说,可以有两 个程序『同时竞争 CPU 的运算单元』,而非透过操作系统的多任务切换!
     这一过程就会让 CPU 好 像『同时有两个核心』的模样!
     因此,虽然大部分 i7 等级的 CPU 其实只有四个实体核心,但透过 HT 的机制, 则操作系统可以抓到八个核心!
     并且让每个核心逻辑上分离,就可以同时运作八个程序了。

     虽然很多研究与测试中,大多发现 HT 虽然可以提升效能,不过,有些情况下却可能导致效能降低 喔!
     因为,实际上明明就仅有一个运算单元嘛!
     不过在鸟哥使用数值模式的情况下, 因为鸟哥操作的数值模式主要为平行运算功能,且运算通常无法达到 100% 的 CPU 使用率, 通常仅有大约 60% 运算量而已。
     因此在鸟哥的实作过程中,这个 HT 确实提升相当多的效能!
     至少应该可以节省鸟哥 大约 30%~50%的等待时间喔!
     不过网络上大家的研究中, 大多说这个是 case by case,而且使用的软件影响很大!
     所以,在鸟哥的例子是启用 HT 帮助很大!您的案例就得要自行研究啰!

*** 内存

    前面提到 CPU 所使用的数据都是来自于主存储器(main memory),不论是软件程序还是数据,都必须 要读入主存储器后 CPU 才能利用。
    *个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM)*, 随机存取内存只有在通电时才能记录与使用,断电后数据就消失了。
    因此我们也称这种 RAM 为挥发性内存。

    DRAM 根据技术的更新又分好几代,而使用上较广泛的有所谓的 SDRAM 与 DDR SDRAM 两种。
    这两种内存的差别除了在于脚位与工作电压上的不同之外,DDR 是所谓的双倍数据传送速度(Double Data Rate), 他可以在一次工作周期中进行两次数据的传送,感觉上就好像是 CPU 的倍频啦!
    所以传输频率方面比 SDRAM 还要好。
    新一代的 PC 大多使用 DDR 内存了。
    下表列出 SDRAM 与 DDR SDRAM 的型号与频率及带宽之间的关系。

    | SDRAM/DDR | 型号      | 数据宽度(bit) | 内部频率(MHz) | 频率速度 | 带宽(频率x宽度) |
    | SDRAM     | PC100     |            64 |           100 |      100 | 800MBytes/sec   |
    | SDRAM     | PC133     |            64 |           133 |      133 | 1064MBytes/sec  |
    | DDR       | DDR-266   |            64 |           133 |      266 | 2.1GBytes/sec   |
    | DDR       | DDR-400   |            64 |           200 |      400 | 3.2GBytes/sec   |
    | DDR       | DDR2-800  |            64 |           200 |      800 | 6.4GBytes/sec   |
    | DDR       | DDR3-1600 |            64 |           200 |     1600 | 12.8GBytes/sec  |

    DDR SDRAM 又随技术的发展, 有 ddr,ddr2,ddr3,ddr4 等, 其中 ddr2的频率倍数是四倍而 ddr3则是8倍.

**** 多通道设计

     由于所有的数据都必须要存放在主存储器,所以主存储器的数据宽度当然是越大越好。
     但传统的总 线宽度一般大约仅达 64 位,为了要加大这个宽度,因此芯片组厂商就将两个主存储器汇整在一起,如 果一支内存可达 64 位,两支内存就可以达到 128 位了,这就是双通道的设计理念。

**** DRAM与SRAM

     除了主存储器之外,事实上整部个人计算机当中还有许许多多的内存存在喔!
     最为我们所知的就是 CPU 内的第二层高速缓存。
     我们现在知道 CPU 的数据都是由主存储器提供,但 CPU 到主存储器之 间还是得要透过内存控制器啊!
     如果某些很常用的程序或数据可以放置到 CPU 内部的话,那么 CPU数据的读取就不需要跑到主存储器重新读取了!
     这对于效能来说不就可以大大的提升了?
     这就是第 二层快取的设计概念。

     因为第二层快取(L2 cache)整合到 CPU 内部,因此这个 L2 内存的速度必须要 CPU 频率相同。
     使用 DRAM 是无法达到这个频率速度的,此时就需要静态随机存取内存(Static Random Access Memory,SRAM)的帮忙了。
     SRAM 在设计上使用的晶体管数量较多,价格较高,且不易做成大容量,不过由 于其速度快, 因此整合到 CPU 内成为高速缓存以加快数据的存取是个不错的方式喔!
     新一代的 CPU 都有内建容量不等的 L2 快取在 CPU 内部,
     以加快 CPU 的运作效能。

**** 只读存储器(ROM)

     主板上面的组件是非常多的,而每个组件的参数又具有可调整性。
     举例来说,CPU 与内存的频率是 可调整的;
     而主板上面如果有内建的网络卡或者是显示适配器时,该功能是否要启动与该功能的各 项参数, 是被记录到主板上头的一个称为 CMOS 的芯片上,这个芯片需要借着额外的电源来发挥记 录功能, 这也是为什么你的主板上面会有一颗电池的缘故。

     那 CMOS 内的数据如何读取与更新呢?还记得你的计算机在开机的时候可以按下[Del]按键来进入一个名为 BIOS 的画面吧?
     *BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的 一个内存芯片中, 这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory, ROM)* 。
     ROM 是一种非挥发性的内存。
     另外,BIOS 对于个人计算机来说是非常重要的, 因 为他是系统在开机的时候首先会去读取的一个小程序喔!
     另外,韧体(firmware)很多也是使用 ROM 来进行软件的写入的。
     韧体像软件一样也是一个被 计算机所执行的程序,然而他是对于硬件内部而言更加重要的部分。
     例如 BIOS 就是一个韧体, BIOS 虽然对于我们日常操作计算机系统没有什么太大的关系,但是他却控制着开机时各项硬件参数的取得! 所以我们会知道很多的硬件上头都会有 ROM 来写入韧体这个软件。

     BIOS 对计算机系统来讲是非常重要的,因为他掌握了系统硬件的详细信息与开机设备的选择等等。
     但是计算机发展的速度太快了, 因此 BIOS 程序代码也可能需要作适度的修改才行,所以你才会在 很多主板官网找到 BIOS 的更新程序啊!
     但是 BIOS 原本使用的是无法改写的 ROM ,因此根本无 法修正 BIOS 程序代码!
     为此,现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM 中。

     #+BEGIN_QUOTE
     很多硬件上面都会有韧体喔!
     例如鸟哥常用的磁盘阵列卡、 10G 的网卡、交换器设备 等等!
     你可以简单的这么想!韧体就是绑在硬件上面的控制软件!
     #+END_QUOTE

*** 显示适配器

    显示适配器又称为 VGA(Video Graphics Array),他对于图形影像的显示扮演相当关键的角色。
    一般 对于图形影像的显示重点在于分辨率与颜色深度,因为每个图像显示的颜色会占用掉内存, 因此显 示适配器上面会有一个内存的容量,这个显示适配器内存容量将会影响到你的屏幕分辨率与颜色深度 的喔!

    #+BEGIN_EXAMPLE
    例题:
    假设你的桌面使用 1024x768 分辨率,且使用全彩(每个像素占用 3bytes 的容量),
    请问你的显示适配器至少需要多 少内存才能使用这样的彩度?
    答:
    因为 1024x768 分辨率中会有 786432 个像素,每个像素占用 3bytes,
    所以总共需要 2.25MBytes 以上才行!但如果考虑屏幕的更新率(每秒钟屏幕的
    更新次数),显示适配器的内存还是越大越好!
    #+END_EXAMPLE

*** 硬盘与储存设备

    大家应该都看过硬盘吧!
    硬盘依据桌上型与笔记本电脑而有分为 3.5 吋及 2.5 吋的大小。
    我们以 3.5 吋的桌面计算机使用硬盘来说明。
    在硬盘盒里面其实 *是由许许多多的圆形磁盘盘、机械手臂、 磁盘 读取头与主轴马达所组成的*.

    实际的数据都是写在具有磁性物质的磁盘盘上头,而读写主要是透过在机械手臂上的读取头(head)来 达成。实际运作时, *主轴马达让磁盘盘转动,然后机械手臂可伸展让读取头在磁盘盘上头进行读写 的动作* 。另外,由于单一磁盘盘的容量有限,因此有的硬盘内部会有两个以上的磁盘盘喔!

*** 磁盘盘上的数据

    既然数据都是写入磁盘盘上头,那么磁盘盘上头的数据又是如何写入的呢?
    其实磁盘盘上头的数据有 点像下面的图标所示:

    [[file:img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-28%20%E4%B8%8B%E5%8D%883.26.11.png]]

    由于磁盘盘是圆的,并且透过机器手臂去读写数据,磁盘盘要转动才能够让机器手臂读写。
    因此,通 常数据写入当然就是以圆圈转圈的方式读写啰!
    所以,当初设计就是在类似磁盘盘同心圆上面切出一个一个的小区块,这些小区块整合成一个圆形,让机器手臂上的读写头去存取。
    *这个小区块就是磁盘的最小物理储存单位, 称之为扇区 (sector), 那同一个同心圆的扇区组合成的圆就是所谓的磁道 (track)*. 由于磁盘里面可能会有多个磁盘盘, 因此在 *所有磁盘盘上面的同一个磁道可以组合成所谓的磁柱 (cylinder)* .

    我们知道同心圆外圈的圆比较大,占用的面积比内圈多啊!所以,为了善用这些空间,因此外围的圆 会具有更多的扇区.
    就如图的示意一般。
    此外,当磁盘盘转一圈时,外圈的扇区数 量比较多,因此如果数据写入在外圈,转一圈能够读写的数据量当然比内圈还要多!
    因此通常数据的读写会由外圈开始往内写的喔!
    这是默认值啊!

    另外,原本硬盘的扇区都是设计成 512byte 的容量, 但因为近期以来硬盘的容量越来越大, 为了减 少数据量的拆解,所以新的高容量硬盘已经有 4Kbyte 的扇区设计!
    购买的时候也需要注意一下。
    也因为这个扇区的设计不同了,因此在磁盘的分区方面,目前有旧式的 MSDOS 兼容模式,以及较 新的 GPT 模式喔!
    在较新的 GPT 模式下,磁盘的分区通常使用扇区号码来设计,跟过去旧的 MSDOS 是透过磁柱号码来分区的情况不同喔!
    相关的说明我们谈到磁盘管理 (第七章) 再来聊!

**** 传输界面

     为了要提升磁盘的传输速度,磁盘与主板的连接界面也经过多次的改版,因此有许多不同的界面喔!
     传统磁盘界面包括有
     - SATA
     - SAS
     - IDE
     - SCSI
     等等. 若考虑外接式磁盘,那就还包括了 USB, eSATA 等等界面喔!

**** 固态硬盘 (Solid State Disk, SSD)

 传统硬盘有个很致命的问题,就是需要驱动马达去转动磁盘盘~这会造成很严重的磁盘读取延迟!
 想想看,你得要知道数据在哪个扇区上面,然后再命令马达开始转, 之后再让读取头去读取正确的数据。
 另外,如果数据放置的比较离散(扇区分布比较广又不连续),那么读写的速度就会延迟更明显!速度快不起来。
 因此, 后来就有厂商拿闪存去制作成高容量的设备,这些设备的连接界面也是透过 SATA 或 SAS,而且外型还做的跟传统磁盘一样!
 所以, 虽然这类的设备已经不能称为是磁盘(因为没有读写头与磁盘盘啊!都是内存!)。
 但是为了方便大家称呼,所以还是称为磁盘!
 只是跟传统磁盘(Hard Disk Drive, HDD)不同, 就称为固态硬盘 (Solid State Disk 或 Solid State Driver, SSD)。

 固态硬盘最大的好处是,它没有马达不需要转动,而是透过内存直接读写的特性,因此除了没数据延 迟且快速之外,还很省电!
 不过早期的 SSD 有个很重要的致命伤,就是这些闪存有『写入次数的 限制』在,因此通常 SSD 的寿命大概两年就顶天了!
 所以数据存放时, 需要考虑到备份或者是可能要使用 RAID 的机制来防止 SSD 的损毁!

 其实我们在读写磁盘时,通常没有连续读写,大部分的情况下都是读写一大堆小文件,因此,你不要妄想传统磁盘一直转少少圈就可以读到所有的数据!
 通常很多小文件的读写,会很操硬盘,因为磁 盘盘要转好多圈!这也很花人类的时间啊!
 SSD 就没有这个问题!也因为如此,近年来在测试磁盘的效能时,有个很特殊的单位,称为每秒读写操作次数 (Input/Output Operations Per Second, IOPS)!
  这个数值越大,代表可操作次数较高,当然效能好的很!

*** 主板

 这个小节我们特别再将主板拿出来说明一下,特别要讲的就是芯片组与扩充卡之间的关系了!

*** 电源供应器

** 数据表示方式

*** 数字系统

*** 文字编码系统

*常用的英文编码表为 ASCII 系统*, 这个编码系统中, 每个符号(英文、数字或符号等)都会占用 1bytes 的记录, 因此总共会有 28=256 种变化。至于 *中文字当中的编码系统早期最常用的就是 big5 这个编码表了* 。每个中文字会占用 2bytes,理论上最多可以有 216=65536,亦即最多可达 6 万多个中文字。 但是因为 big5 编码系统并非将所有的位都拿来运用成为对照,所以并非可达这么多的中文字码的。目前 big5 仅定义了一万三千多个中文字,很多中文利用 big5 是无法成功显示的~所以才会有造字程序说。
big5 码的中文字编码对于某些数据库系统来说是很有问题的, 某些字码例如『许、盖、功』等字, 由于这几个字的内部编码会被误判为单/双引号,在写入还不成问题,在读出数据的对照表时, 常常就 会变成乱码。
不只中文字,其他非英语系国家也常常会有这样的问题出现啊!

为了解决这个问题,由国际组织 ISO/IEC 跳出来制订了所谓的 Unicode 编码系统, 我们常常称呼的 UTF8 或万国码的编码就是这个咚咚。
因为这个编码系统打破了所有国家的不同编码, 因此目前因 特网社会大多朝向这个编码系统在走,所以各位亲爱的朋友啊,记得将你的编码系统修订一下喔!

** 软件程序运作

*** 机器程序与编译程序

我们前面谈到计算机只认识 0 与 1 而已,而且计算机最重要的运算与逻辑判断是在 CPU 内部, 而 CPU 其实是具有微指令集的。
因此,我们需要 CPU 帮忙工作时,就得要参考微指令集的内容, 然 后撰写让 CPU 读的懂的脚本给 CPU 执行,这样就能够让 CPU 运作了。
不过这样的流程有几个很麻烦的地方,包括:
- 需要了解机器语言 ::
机器只认识 0 与 1,因此你必须要学习直接写给机器看的语言!
这个地方相当的难呢!
- 需要了解所有硬件的相关功能函数 ::
因为你的程序必须要写给机器看, 当然你就得要参考机器本身的功能, 然后针对该功能去撰写程序代码。
例如,你要让 DVD 影片能够放映, 那就得要参考 DVD 光驱的硬件信息 才行。
万一你的系统有比较冷门的硬件,光是参考技术手册可能会昏倒~
- 程序不具有可移植性 ::
每个 CPU 都有独特的微指令集,同样的,每个硬件都有其功能函数。
因此,你为 A 计算机写的程序,理论上是没有办法在 B 计算机上面运作的!
而且程序代码的修改非常困难!
因为是机器 码,并不是人类看的懂得程序语言啊!
- 程序具有专一性 ::
因为这样的程序必须要针对硬件功能函数来撰写, 如果已经开发了一支浏览器程序,想 要再开发文件管理程序时,还是得从头再参考硬件的功能函数来继续撰写, 每天都在和『硬件』挑战!

那怎么解决啊?
为了解决这个问题,计算机科学家设计出一种让人类看的懂得程序语言, 然后创造 一种『编译程序』来将这些人类能够写的程序语言转译成为机器能看懂得机器码, 如此一来我们修改与撰写程序就变的容易多了!
目前常见的编译程序有 C, C++, Java, Fortran 等等。

所以这样已经将程序的修改问题处理完毕了。
问题是,在这样的环 境底下我们还是得要考虑整体的硬件系统来设计程序喔!
举例来说,当你需要将运作的数据写入内存中,你就得要自行分配一个内存区块出来让自己的数据能 够填上去, 所以你还得要了解到内存的地址是如何定位的,啊!
眼泪还是不知不觉的流了下来... 怎 么写程序这么麻烦啊!
为了要克服硬件方面老是需要重复撰写句柄的问题,所以就有操作系统(Operating System, OS)的出现了!
什么是操作系统呢?底下就来谈一谈先!

*** 操作系统

如同前面提到的, 在早期想要让计算机执行程序就得要参考一堆硬件功能函数,并且学习机器语言才 能够撰写程序。
同时每次写程序时都必须要重新改写, 因为硬件与软件功能不见得都一致之故。
那如果我能够将所有的硬件都驱动, 并且提供一个发展软件的参考接口来给工程师开发软件的话, 那发展软件不就变的非常的简单了?
那就是操作系统啦!

**** 操作系统核心(kernel)

*操作系统(Operating System, OS)其实也是一组程序, 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件* 。
我们刚刚谈到计算机没有软件只是一堆废铁, 那么操作系统的功能就是让 CPU 可以开始判断逻辑与运算数值、让主存储器可以开始加载/读出数据与程序代码、让硬盘可 以开始被存取、让网络卡可以开始传输数据、让所有周边可以开始运转等等。
总之,硬件的所有动作都必须要透过这个操作系统来达成就是了。

上述的功能就是操作系统的核心(Kernel)了!
你的计算机能不能做到某些事情,都与核心有关!
只有核心有提供的功能, 你的计算机系统才能帮你完成!
举例来说, 你的核心并不支持 TCP/IP 的网络协议, 那么无论你购买了什么样的网卡,这个核心都无法提供网络能力的!
但是单有核心我们使用者也不知道能作啥事的~因为核心主要在管控硬件与提供相关的能力(例如存 取硬盘、网络功能、CPU 资源取得等), 这些管理的动作是非常的重要的,如果使用者能够直接使用 到核心的话, 万一用户不小心将核心程序停止或破坏, 将会导致整个系统的崩溃!
因此核心程序所 放置到内存当中的区块是受保护的! 并且开机后就一直常驻在内存当中。

#+BEGIN_QUOTE
所以整部系统只有核心的话,我们就只能看着已经准备好运作(Ready)的计算机系统, 但无法操作他!
好像有点望梅止渴的那种感觉啦!这个时候就需要软件的帮忙了!
#+END_QUOTE

**** 系统呼叫(SystemCall)

既然我的硬件都是由核心管理, 那么如果我想要开发软件的话, 自然就得要去参考这个核心的相关功 能!
唔!如此一来不是从原本的参考硬件函数变成参考核心功能,还是很麻烦啊!
有没有更简单的方法啊!
为了解决这个问题,操作系统通常会提供一整组的开发接口给工程师来开发软件!
工程师只要遵守该开发接口那就很容易开发软件了!
举例来说, 我们学习 C 程序语言只要参考 C 程序语言的函式即可, 不需要再去考虑其他核心的相关功能, 因为核心的系统呼叫接口会主动的将 C 程序语言的相关语法转成核心可以了解的任务函数, 那核心自然就能够顺利运作该程序了!
如果我们将整个计算机系统的相关软/硬件绘制成图的话,他的关系有点像这样:

[[file:img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-28%20%E4%B8%8B%E5%8D%884.08.01.png]]


计算机系统主要由硬件构成,然后核心程序主要在管理硬件,提供合理的计算机系统资源分配(包括 CPU 资源、内存使用资源等等), 因此只要硬件不同(如 x86 架构与 RISC 架构的 CPU),核心就得要进行修改才行。
而由于核心只会进行计算机系统的资源分配,所以在上头还需要有应用程序的提供, 用户才能够操作系统的。

为了保护核心,并且让程序设计师比较容易开发软件,因此操作系统除了核心程序之外,通常还会提 供一整组开发接口,那就是系统呼叫层。
软件开发工程师只要遵循公认的系统呼叫参数来开发软件, 该软件就能够在该核心上头运作。
所以你可以发现,软件与核心有比较大的关系,与硬件关系则不大!
硬件也与核心有比较大的关系!
至于与用户有关的,那就是应用程序啦!

#+BEGIN_QUOTE
在定义上,只要能够让计算机硬件正确无误的运作,那就算是操作系统了。
所以说, 操作系统其实就是核心与其提供的接口工具, 不过就如同上面讲的, 因为最阳春的核心缺乏了与用户沟通的亲和接口, 所以在目前, 一般我们提到的『操作系统』都会包含核心与相关的用户应用软件呢!
#+END_QUOTE

简单的说,上面的图示可以带给我们底下的概念:
- 操作系统的核心层直接参考硬件规格写成, 所以同一个操作系统程序不能够在不一样的硬件架构下运作。 ::
举例来说,个人计算机版的 Windows 8.1 不能直接在 ARM 架构 (手机与平板硬件) 的计算机下运作。
- 操作系统只是在管理整个硬件资源, 包括 CPU、内存、输入输出装置及文件系统文件。 ::
如果没有其他的应 用程序辅助,操作系统只能让计算机主机准备妥当(Ready)而已! 并无法运作其他功能。 所以你现在知道为何 Windows 上面要达成网页影像的运作还需要类似 PhotoImpact 或 Photoshop 之类的软件安装了吧?
- 应用程序的开发都是参考操作系统提供的开发接口, 所以该应用程序只能在该操作系统上面运作而已,不可以在其他操作系统上面运作的。 ::
现在您知道为何去购买在线游戏的光盘时,光盘上面会明明白白的写着 该软件适合用于哪一种操作系统上了吧? 也该知道某些游戏为何不能够在 Linux 上面安装了吧?

**** 核心功能

既然核心主要是在负责整个计算机系统相关的资源分配与管理,那我们知道其实整部计算机系统最重
要的就是 CPU 与主存储器, 因此,核心至少也要有这些功能的:

- 系统呼叫接口(System call interface) ::
刚刚谈过了,这是为了方便程序开发者可以轻易的透过与核心的沟通,将硬件的资源进一步的利用, 于是 需要有这个简易的接口来方便程序开发者。
- 程序管理(Process control) ::
总有听过所谓的『多任务环境』吧?
一部计算机可能同时间有很多的工作跑到 CPU 等待运算处理, 核心这个时候必须要能够控制这些工作,让 CPU 的资源作有效的分配才行!
另外,良好的 CPU 排程机制(就是 CPU 先运作那个工作的排列顺序)将会有效的加快整体系统效能呢!
- 内存管理(Memory management) ::
控制整个系统的内存管理, 这个内存控制是非常重要的, 因为系统所有的程序代码与数据都必须要先存放在内存当中。
通常核心会提供虚拟内存的功能,当内存不足时可以提供内存置换(swap)的功能哩。
- 文件系统管理(Filesystem management) ::
文件系统的管理, 例如数据的输入输出(I/O)等等的工作啦!
还有不同文件格式的支持啦等等, 如果你的核心不认识某个文件系统,那么您将无法使用该文件格式的文件啰!
例如:Windows 98 就不认识 NTFS 文件格式的硬盘;
- 装置的驱动(Device drivers) ::
就如同上面提到的, 硬件的管理是核心的主要工作之一 , 当然啰 , 装置的驱动程序就是核心需要做的事情啦!
好在目前都有所谓的『可加载模块』功能, 可以将驱动程序编辑成模块, 就不需要重新的编译核心啦!
这个也会在后续的第十九章当中提到的!

**** 操作系统与驱动程序

老实说,驱动程序可以说是操作系统里面相当重要的一环了!
不过,硬件可是持续在进步当中的!
包括主板、显示适配器、硬盘等等。
那么比较晚推出的较新的硬件,例如显示适配器,我们的操作系统 当然就不认识啰!
那操作系统该如何驱动这块新的显示适配器?
为了克服这个问题, 操作系统通常会提供一个开发接口给硬件开发商,让他们可以根据这个接口设计可以驱动他们硬件的『驱动程序』, 如此一来,只要使用者安装驱动程序后,自然就可以在他们的操作系统上面驱动这块显示适配器了。

我们可以得到几个小重点:
1. 操作系统必须要能够驱动硬件,如此应用程序才能够使用该硬件功能;
2. 一般来说,操作系统会提供开发接口,让开发商制作他们的驱动程序;
3. 要使用新硬件功能,必须要安装厂商提供的驱动程序才行;
4. 驱动程序是由厂商提供的,与操作系统开发者无关。

*** 应用程序

** 重点回顾

- 计算器的定义为: *接受用户输入指令与数据,经由中央处理器的数学与逻辑单元运算处理后,以产生或储 存成有用的信息*;
- 计算机的五大单元包括:输入单元、输出单元、控制单元、算数逻辑单元、记忆单元五大部分。其中 CPU 占有控制、算术逻辑单元,记忆单元又包含主存储器与辅助内存;
- 数据会流进/流出内存是 CPU 所发布的控制命令,而 CPU 实际要处理的数据则完全来自于主存储器;
- CPU 依设计理念主要分为:精简指令集(RISC)与复杂指令集(CISC)系统;
- 关于 CPU 的频率部分:外频指的是 CPU 与外部组件进行数据传输时的速度,倍频则是 CPU 内部用来加速 工作效能的一个倍数, 两者相乘才是 CPU 的频率速度;
- 新的 CPU 设计中,已经将北桥的内存控制芯片整合到 CPU 内,而 CPU 与主存储器、显示适配器沟通的 总线通常称为系统总线。 南桥就是所谓的输入输出(I/O)总线,主要在联系硬盘、USB、网络卡等接口设备;
- CPU 每次能够处理的数据量称为字组大小(word size),字组大小依据 CPU 的设计而有 32 位与 64 位。 我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的!
- 个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM), 至于 CPU内部的第二层快取则使用静态随机存取内存(Static Random Access Memory, SRAM);
- BIOS(Basic Input Output System)是一套程序,这套程序是写死到主板上面的一个内存芯片中, 这个内存芯片在没有通电时也能够将数据记录下来,那就是只读存储器(Read Only Memory, ROM);
- 目前主流的外接卡界面大多为 PCIe 界面,且最新为 PCIe 3.0,单信道速度高达 1GBytes/s 常见的显示适配器连接到屏幕的界面有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送影像与声音。
- 传统硬盘的组成为:圆形磁盘盘、机械手臂、磁盘读取头与主轴马达所组成的,其中磁盘盘的组成为扇区、 磁道与磁柱;
- 磁盘连接到主板的界面大多为 SATA 或 SAS,目前桌机主流为 SATA 3.0,理论极速可达 600Mbytes/s。
- 常见的文字编码为 ASCII,繁体中文编码主要有 Big5 及 UTF8 两种,目前主流为 UTF8
- 操作系统(Operating System, OS)其实也是一组程序, 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
- 计算机主要以二进制作为单位,常用的磁盘容量单位为 bytes,其单位换算为 1 Byte = 8bits。
- 最阳春的操作系统仅在驱动与管理硬件,而要使用硬件时,就得需要透过应用软件或者是壳程序(shell)的功能, 来呼叫操作系统操纵硬件工作。目前称为操作系统的,除了上述功能外,通常已经包含了日常工作所 需要的应用软件在内了。

* Linux 是什么与如何学习

众所皆知的,Linux 的核心原型是 1991 年由托瓦兹(Linus Torvalds)写出来的,但是托瓦兹为何可以写出 Linux 这个操作系统?
为什么他要选择 386 的计算机来开发?
为什么 Linux 的发展可以这么迅速?
又为什么 Linux 是免费且可以自由学习的?
以及目前为何有这么多的 Linux 套件版本(distributions)呢?
了解这些东西后,才能够知道为何 Linux 可以免除专利软件之争, 并且了解到 Linux 为何可以同时在个人计算机与大型主机上面大放异彩!
所以,在实际进入 Linux 的世界前, 就让我们来谈一谈这些有趣的历史故事吧! ^_^

** Linux 是什么

*** Linux 是什么?操作系统/应用程序?

*Linux 就是一套操作系统*, 包括核心和系统呼叫.

#+BEGIN_QUOTE
Torvalds 先生在 1991 年写出 Linux 核心的时候,其实该核心仅能『驱动 386 所有的 硬件』而已, 所谓的『让 386 计算机开始运作,并且等待用户指令输入』而已,事实上,当时能够在 Linux 上面跑的软件还很少呢!
#+END_QUOTE

#+BEGIN_EXAMPLE
例题:
请问 Windows 操作系统能否在苹果公司的麦金塔计算机(MAC)上面安装与运作?
答:
由上面的说明中,我们知道硬件是由『核心』来控制的,而每种操作系统都有他自己的核心。
在 2006 年以前的苹果计算机公司是请 IBM 公司帮忙开发硬件(所谓的Power CPU),而苹
果计算机公司则在该硬件架构上发展自家的操作系统(就是俗称的麦金塔,MAC 是也)。
Windows 则是开发在 x86 架构上的操作系统之一, 因此 Windows是没有办法安装到
麦金塔计算机硬件上面的。不过,在 2006 年以后, 苹果计算机转而请 Intel 设计其硬件
架构, 亦即其硬件架构已经转为x86系统, 因此在 2006 年以后的苹果计算机若使用
x86架构时,其硬件则『可能』可以安装 Windows 操作系统了。不过,你可能需要自己想些
方式来处理该硬件的兼容性啰!
#+END_EXAMPLE

*** Linux之前, Unix的历史

早在 Linux 出现之前的二十年(大约在 1970 年代),就有一个相当稳定而成熟的操作系统存在了! 那就是 Linux 的老大哥『Unix』是也!

众所皆知的,Linux 的核心是由 Linus Torvalds 在 1991 年的时候给他开发出来的,并且丢到网络上提供大家下载,后来大家觉得这个小东西(Linux Kernel)相当的小而精巧, 所以慢慢的就有相当多朋友投入这个小东西的研究领域里面去了!

**** 1969年以前:一个伟大的梦想--Bell,MIT与GE的『Multics』系统

早期的计算机并不像现在的个人计算机一样普遍, 他可不是一般人碰的起的呢~
除非是军事或者是高科技用途, 或者是学术单位的前瞻性研究, 否则真的很难接触到。
非但如此,早期的计算机架构 还很难使用, 除了指令周期并不快之外, 操作接口也很困扰的!
因为那个时候的输入设备只有卡片阅读机、输出设备只有打印机, 用户也无法与操作系统互动(批次型操作系统)。

在那个时候, 写程序是件很可怜的事情, 因为程序设计者, 必须要将程序相关的信息在读卡纸上面打洞, 然后再将读卡纸插入卡片阅读机来将信息读入主机中运算。
光是这样就很麻烦了, 如果程序有个小地方写错, 哈哈!光是重新打卡就很惨,加上主机少,用户众多,光是等待,就耗去很多的时间了!

在那之后, 由于硬件与操作系统的改良, 使得后来可以使用键盘来进行信息的输入。
不过, 在一间学校里面, 主机毕竟可能只有一部, 如果多人等待使用, 那怎么办?
大家还是得要等待啊!
好在 1960 年代初期麻省理工学院(MIT)发展了所谓的: 『兼容分时系统(Compatible Time-Sharing System, CTSS)』,
它可以让大型主机透过提供数个终端机(terminal)以联机进入主机, 来利用主机的资源进行运算工作。

#+BEGIN_QUOTE
这个兼容分时系统可以说是近代操作系统的始祖呢!
他可以让多个使用者在某一段时 间内分别使用 CPU 的资源, 感觉上你会觉得大家是同时使用该主机的资源!
事实上,是 CPU 在每个使用者的工作之间进行切换, 在当时,这可是个划时代的技术喔!
#+END_QUOTE

如此一来,无论主机在哪里,只要在终端机前面进行输入输出的作业,就可利用主机提供的功能了。
不过,需要注意的是,此时终端机只具有输入/输出的功能,本身完全不具任何运算或者软件安装的 能力。
而且,比较先进的主机大概也只能提供 30 个不到的终端机而已。

为了更加强化大型主机的功能,以让主机的资源可以提供更多使用者来利用,所以在 1965 年前后,由 贝尔实验室(Bell)、麻省理工学院(MIT)及奇异公司(GE, 或称为通用电器)共同发起了 Multics 的计划, Multics 计划的目的是想要让大型主机可以达成提供 300 个以上的终端机联机使用的目标。
不过, 到了 1969 年前后, 计划进度落后, 资金也短缺, 所以该计划虽然继续在研究,但贝尔实验室还是退出了该计划的研究工作。 (注:Multics 有复杂、多数的意思存在。)

#+BEGIN_QUOTE
最终 Multics 还是有成功的发展出他们的系统,完整的历史说明可以参考:http://www.multicians.org/ 网站内容。
 Multics 计划虽然后来没有受到很大的重视,但是他培养出来的人材是相当优 秀的! ^_^
#+END_QUOTE

**** 1969 年:Ken Thompson 的小型 file server system

在认为 Multics 计划不可能成功之后,贝尔研究室就退出该计划。
不过,原本参与 Multics 计划的人 员中,已经从该计划当中获得一些点子, Ken Thompson 就是其中一位!

Thompson 因为自己的需要,希望开发一个小小的操作系统以提供自己的需求。
 在开发时,有一部 DEC (Digital Equipment Corporation)公司推出的 PDP-7 刚好没人使用,于是他就准备针对这部主机进 行操作系统核心程序的撰写。
本来 Thompson 应该是没时间的(有家有小孩的宿命?), 无巧不巧的是, 在 1969 年八月份左右,刚好 Thompson 的妻儿去了美西探亲, 于是他有了额外的一个月的时间好好的待在家将一些构想实现出来!
经过四个星期的奋斗,他终于以汇编语言(Assembler)写出了一组核心程序,同时包括一些核心工具程 序, 以及一个小小的文件系统。
那个系统就是 Unix 的原型!
当时 Thompson 将 Multics 庞大的复杂系统简化了不少,于是同实验室的朋友都戏称这个系统为:Unics。(当时尚未有 Unix 的名称)
Thompson 的这个文件系统有两个重要的概念,分别是:

- *所有的程序或系统装置都是文件*
- *不管建构编辑器还是附属文件,所写的程序只有一个目的,且要有效的完成目标* 。

* 2

* 3 安装 CentOS7.x

Linux distributions 越作越成熟,所以在安装方面也越来越简单!
虽然安装非常的简单, 但是刚刚前一章所谈到的基础认知还是需要了解的, 包括 MBR/GPT, partition, boot loader, mount, software 的选择等等的数据。
这一章鸟哥的安装定义为『一部练习机』, 所以安装的方式都是以最简单的方式来处理的。
另外,鸟哥选择的是 CentOS 7.x 的版本来安装的啦!
在内文中, 只要标题内含有(Option) 的, 代表是鸟哥额外的说明,你应该看看就好,不需要实作喔!^_^

** 本练习机的规划--尤其是分区参数

- Linux 主机的角色定位 ::
本主机架设的主要目的在于练习 Linux 的相关技术, 所以几乎所有的数据都想要安装进来。
因此连较耗系统资源的 X Window System 也必须要包含进来才行。
- 选择的 distribution ::
由于我们对于 Linux 的定位为『服务器』的角色, 因此选择号称完全兼容于商业版 RHEL 的社群版本, 就是 CentOS 7.x 版啰。
- 计算机系统硬件配备 ::
于虚拟机越来越流行, 因此鸟哥这里使用的是 Linux 原生的 KVM 所搭建出来的虚拟硬件环境。
对于 Linux 还不熟的朋友来说, 建议你使用virtualbox 来进行练习吧!
至于鸟哥使用的方式可以参考文末的延伸阅读,里面有许多的文件可参考b(注 1)! 鸟哥的虚拟机硬件配备如下:  o CPU 等级类别:透过 Linux 原生的虚拟机管理员的处理,使用本机的 CPU 类型。本机 CPU 为 Intel i7 2600 这颗 三、四年前很流行的 CPU 喔! 至于芯片组则是 KVM 自行设定的喔!o 内存:透过虚拟化技术提供大约 1.2G 左右的内存o 硬盘:使用一颗 40GB 的 VirtI/O 芯片组的磁盘,因此磁盘文件名应该会是 /dev/vda 才对。同时提供一 颗 2GB 左右的 IDE 界面的磁盘, 这颗磁盘仅是作为测试之用,并不安装系统!因此还有一颗 /dev/sda 才对喔!o 网络卡:使用 bridge (桥接) 的方式设定了对外网卡,网卡同样使用 VirtI/O 的芯片,还好 CentOS 本身就 有提供驱动程序, 所以可以直接抓到网络卡喔!o 显示适配器(VGA):使用的是在 Linux 环境下运作还算顺畅的 QXL 显示适配器,给予 60M 左右的显示内存。o 其他输入/输出装置:还有仿真光驱、USB 鼠标、USB 键盘以及 17 吋屏幕输出等设备喔!
